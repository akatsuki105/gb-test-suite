# GameBoyのCPU命令の挙動テスト

このROMは、`STOP`と11の不正なオペコードを除くすべてのCPU命令の挙動をテストします。

エッジケースなデータを含む命令を実行し、その結果と他のレジスタが変更されていないかどうかを検証するという、かなり綿密なテストを行っています。

異なるレジスタに対して同じ処理を行う命令は、エミュレータがそれぞれを独立して実装している場合には、それぞれが同じようにテストされます。

一部のサブテストは他のサブテストの半分ほどの時間で終了します。

テストを通らなかった命令は次のように列挙されます。

```
[CB] opcode
```

テストフレームワーク自体が、ある程度基本的な命令の動作が正しいことを前提としているため、当然ながら適切な診断ができないエラーもあります。

## テスト内部の処理について

主なテストでは、各命令をループで実行し、入力ではレジスタの値を変化させ、出力ではその値を調べるというフレームワークを使用しています。

正しい値のテーブルを保持するのではなく、単純にすべての出力のCRC-32チェックサムを計算して、それを正しい値と比較します。

命令はいくつかのグループに分けられ、それぞれの命令の挙動に適した入力値でテストを行います。

例えば、ビットテスト命令には、各ビットが適切に処理されているかどうかを確認するために`$01, $02, $04 ... $40, $80`が入力され、算術命令には、キャリーとハーフキャリーを行使するために`$01, $0F, $10, $7F, $FF`が入力されます。

いくつかの命令は、その独自性のために特殊な入力値でのテストを行っています。

## Multi-ROM

このディレクトリには、すべてのテストを一括で実行してくれる1つのテストROMがあります。(`cpu_instrs.gb`)

テストの番号を表示し、テストを実行し、パスした場合は`ok`、そうでない場合は失敗したテストの数を表示します。

テストが全部終わるとビープ音がなります。

テストが失敗したときは、`individual/`の中から該当するROMを探して、失敗したテストだけを実行することができます。

結果の画面がコンパクトになっているのは、結果が上にスクロールして前の結果が見えなくならないようにするためです。

現在のところ、結果の画面を目視で見るのではなく、プログラムによって自動的にテスト結果を判定するための画一的な方法はありません。もし、エミュレータのテストを完全に自動化しようとしているのであれば、私に連絡してください。

簡単な方法としては、正確なエミュレータですべてのテストが実行された後のスクリーンショット、または1つのテストのチェックサムを撮影し、それを自分のエミュレータの実行結果と比較することです。

## エラーコード

テストが失敗した場合は、エラーコードと問題点の簡単な説明が表示されます。エラーコードの詳細については、`source/`にある対応するソースファイルを参照してください。

コードの中で`set_test n`のコードが実行されると、次に`set_test m`が実行されるまで、テストが失敗するとエラーコードとして`n`が表示されます。

エラーコードが1の場合は、一般的なテストの失敗パターンで、付随してさらに情報が出力されます。

サブテストが失敗した場合は、ファイルのそれ以降のテストは実行されないことに注意してください。

## 画面出力

情報は最低限のLCDの機能を必要とする方法で画面に表示され、LCD出力が全くサポートされていない場合はテストはハングアップしません。

具体的には、LYをポーリングしてvblankを待っている間、時間がかかりすぎるとタイムアウトしてしまうので、LYから読み取った値が常に同じ値を返してもテストがハングアップしないようにしています。

エミュレータがスクロールに対応していない場合もテストは動作します。この場合、テキストは画面の上部から表示されます。

画面に表示された文字については、SBに文字を書き込み、SCに`0x81`を書き込むことで、通信ポートにも送信されます。

これは、画面外にスクロールするような多くの情報を出力するテストに有効です。

## ソースコード

テストのソースコードは、すべて`source/`に含まれています。このソースコードを使って、個々のテストROMをビルドすることができます。

マルチテストのソースコードは、すべてを組み立てるのが複雑なため、含まれていません。

コードは [wla-dx](https://github.com/vhelin/wla-dx)アセンブラで書かれています。特定のテストをアセンブルするには、以下のコマンドを実行します。

```sh
wla -o "source_filename.s" test.o
wlalink linkfile test.gb
```

`common/`には画面出力など、テストコードでよく使われる基本的な処理のコードが含まれています。

## Internal framework operation

テストでは、テスト内容を設定し、テスト結果を報告し、終了するための共通のフレームワークを使用します。

すべてのファイルには、まずROMヘッダとシェルコード[<sup>[1]</sup>](#shellcode)を設定する`shell.inc`が含まれており、その他の一般的に使用されるモジュールも含まれています。

特徴としては、テストコードがまず`$D000`の内部RAMにコピーされ、そこから実行されます。

RAM領域にコピーするため、テストコードの自己修正が可能となり、一般的なROMのように書き換え可能な領域をカートリッジ内に持たない私の開発用カートリッジでも同じようにコードが実行されるようになりました。

いくつかのマクロは、次のような一般的な処理を簡略化するために使用されます。

Macro | Behavior
-- | -- 
`wreg addr,data` | Writes data to addr using LDH
`lda  addr`          | Loads byte from addr into A using LDH
`sta  addr`          | Stores A at addr using LDH
`delay n`            | Delays n cycles, where NOP = 1 cycle
`delay_msec n`       | Delays n milliseconds
`set_test n,"Cause"` | Sets failure code and optional string

関数やマクロは、定義されている場所でコメントによるドキュメントが書かれています。

## 補足

<a name="shellcode">[1]</a>シェルコード: コンピュータセキュリティにおいて、ソフトウェアのセキュリティホールを利用するペイロードとして使われるコード断片。ここでは**特定のコードを埋め込んで実行する処理を行うためのコード**という意味が適切か
